{"version":"0.3.0","body":"namespace fr {\n    //DEFAULT SEPARATOR FOR MULTIPLE JOINS\n    let SEPARATOR = \"~~~\";\n    //ABSTRACT DEV SHEET NAME FOR FORMULA HARDCODING\n    const DEV_SHEET_NAME = \"___DEV_SHEET_NULL#859132\";\n\n    export function get_separator(): string {\n        return SEPARATOR;\n    }\n    export function set_separator(separator: string) {\n        SEPARATOR = separator;\n    }\n\n    //Helper function for DataFrame Initialization\n    function column_violates_separator(key: string) {\n        if (key.includes(get_separator())) {\n            throw new Error(`Input key: ${key} contains the interal frost separator ${get_separator()}, this may cause unintended behavior. \\n Please modify the column name using df.rename(), or change the separator value using the fr.set_separator()`);\n        }\n    }\n\n    function detectTypeFromString(s: string): (\"string\" | \"number\" | \"boolean\") {\n        if (!s) {\n            s = \"\";\n        }\n        s = s.toString();\n        if (/^-?\\d+(\\.\\d+)?$/.test(s) || s == \"\") {\n            return \"number\";\n        }\n        if (['true', 'false'].includes(s.toLocaleLowerCase())) {\n            return \"boolean\"\n        }\n        else {\n            return \"string\"\n        }\n    }\n    function detectColumn(col: string[]): (\"string\" | \"number\" | \"boolean\") {\n        // Detect the type of each value in the column\n        let types = col.map(i => detectTypeFromString(i));\n\n        // Check if all types are the same\n        const uniqueTypes = Array.from(new Set(types));\n\n        // If there's only one unique type, return that type; otherwise, return \"string\"\n        if (uniqueTypes.length === 1) {\n            return uniqueTypes[0];\n        } else {\n            return \"string\";\n        }\n    }\n    function parseValue(input: CellValue, parse_method: (\"string\" | \"number\" | \"boolean\")): CellValue {\n        switch (parse_method) {\n            case \"string\": return input.toString();\n            case \"boolean\": return input.toString() == \"true\";\n            case \"number\": return parseFloat(input.toString());\n            default: throw SyntaxError(\"Error parsing value: parsing method must be either 'string','boolean',or 'number'\");\n        }\n    }\n    export function read_range(range: ExcelScript.Range): DataFrame {\n        return new DataFrame(range.getValues());\n    }\n    export function read_sheet(Sheet: ExcelScript.Worksheet): DataFrame {\n        let rng = Sheet.getUsedRange();\n        if (!rng) {\n            throw new Error(`Input Sheet \"${Sheet.getName()}\" is empty, unable to create DataFrame`);\n        }\n        return read_range(rng);\n    }\n\n    export function read_json(json: string): DataFrame {\n        /* Parse an input JSON-coded string to create a DataFrame*/\n        return new DataFrame(JSON.parse(json))\n    }\n\n    export function read_after(Sheet: ExcelScript.Worksheet, n_rows: number, n_cols: number) {\n        let rng = Sheet.getUsedRange();\n        let new_rng = rng.getOffsetRange(n_rows, n_cols).getUsedRange();\n        return read_range(new_rng);\n    }\n\n    //Helper function for CSV parsing Fixes occurences like \"1,024\"\n    function remove_chars_within_quotes(longtext: string): string {\n        //Removes line breaks and commas within quotes using a stack, runs in O(n) space and memory\n        let stklen = 0;\n        let newstring = \"\"\n        for (let i = 0; i < longtext.length; i++) {\n            let char = longtext[i];\n            //Stack counter to determine whether we are inside double quotes\n            if (char == '\"') {\n                if (stklen == 0) {\n                    stklen = 1;\n                }\n                else {\n                    stklen = 0;\n                }\n                newstring += \"\"\n            }\n            //If we are in quotes, these are problem characters.\n            else if (stklen == 1 && (char == \"\\n\" || char == \",\")) {\n                if (char == \",\") {\n                    newstring += \"\"\n                }\n                if (char == \"\\n\") {\n                    newstring += \" \"\n                }\n            }\n            else {\n                newstring += char\n            }\n        }\n        return newstring\n    }\n\n    export function read_csv(input_text: string, errors: (\"raise\" | \"coerce\") = \"raise\", start_index: number = 0, line_separator: string = \"\\n\"): DataFrame {\n        let cleaned_text = remove_chars_within_quotes(input_text);\n        let line_split_arr: string[] = [];\n        //Determine splitting method, then split\n        if (cleaned_text.includes(line_separator)) {\n            line_split_arr = cleaned_text.split(line_separator);\n        }\n        else {\n            console.log(`No split marker in ${cleaned_text}`);\n        }\n\n        let output: string[][] = line_split_arr.map(row => row.split(\",\"))\n\n        //Find sizes and reshape array to ensure that the input is square and importable\n\n        const maxLength = output.reduce((max, row) => Math.max(max, row.length), 0);\n        output.forEach(row => {\n            if (row.length != maxLength) {\n                if (errors == \"raise\") {\n                    throw new TypeError(\"Error in CSV parsing. Rows are not all the same size. This may cause unintended behavior\\nIf this is intentional, use errors='coerce'\");\n                }\n                else {\n                    while (row.length < maxLength) {\n                        row.push(null);\n                    }\n                }\n            }\n        });\n\n        return new DataFrame(output.slice(start_index));\n    }\n\n    export function to_numeric(column: CellValue[]): number[] {\n        return column.map(row => parseFloat(row.toString()));\n    }\n\n    export function combine_dfs(dfs: DataFrame[], columnSelection: (\"inner\" | \"outer\" | \"left\") = \"outer\"):DataFrame{\n        if (dfs.length == 0){\n            throw RangeError(\"Please input at least 1 DataFrame to use combine_dfs()\")\n        }\n        else if (dfs.length == 1){\n            return dfs[0];\n        }\n\n        let base_df = dfs[0];\n        return base_df.concat_all(columnSelection, ...dfs.slice(1));\n    }\n\n    export function sum(nums: number[]):number{\n        return nums.reduce((acc, x) => acc + x,0);\n    }\n    export function count(nums: number[]):number{\n        return nums.filter(x => !isNaN(x)).length;\n    }\n    export function mean(nums:number[]):number{\n        return sum(nums)/nums.length;\n    }\n    export function min(nums:number[]):number{\n        return Math.min(...nums);\n    }\n    export function max(nums:number[]):number{\n        return Math.max(...nums);\n    }\n    export function range(nums:number[]):number{\n        return max(nums) - min(nums);\n    }\n    export function product(nums:number[]):number{\n        return nums.reduce((acc, x) => acc * x, 1);\n    }\n\n    export function row_to_array(row:Row):CellValue[]{\n        return Object.values(row);\n    }\n\n    export type CellValue = string|number|boolean; //Improve type clarity\n    export type Row = { [key: string]: CellValue };\n\n    export class DataFrame {\n        columns: string[]\n        __headers: Set<string>\n        dtypes: { [key: string]: (\"string\" | \"number\" | \"boolean\") }\n        values: Row[];\n\n        constructor(data: CellValue[][]) {\n            let str_data = data as string[][];\n            let headers = str_data[0];\n            str_data = str_data.slice(1);\n            this.dtypes = {};\n\n            //Fix duplicate headers by adding extra labels\n            let times_seen = {};\n            headers.forEach((header, i) => {\n                if (header in times_seen) {\n                    headers[i] = header + \"_\" + times_seen[header]\n                    times_seen[header] = times_seen[header] + 1;\n                }\n                times_seen[header] = 1;\n            })\n\n            this.columns = headers;\n            this.__headers = new Set(this.columns);\n            this.values = []\n            for (let row of str_data) {\n                let row_values: Row = {};\n                headers.forEach((header, i) => row_values[header] = row[i]);\n                this.values.push(row_values);\n            }\n\n            //Enforce type security. Can check all vals in column, but this may slow down other methods\n            headers.forEach((header, col_idx) => {\n                this.dtypes[header] = detectColumn(str_data.map(row => row[col_idx]))\n                if (this.dtypes[header] != \"string\" && this.values.length > 0 && typeof (this.values[0][header]) == \"string\") {\n                    //console.log(\"Attempting to correct dtypes\");\n                    this.values.map(row => row[header] = parseValue(row[header], this.dtypes[header]));\n                }\n            });\n        }\n\n        private __assign_inplace(other:DataFrame, inplace:boolean){\n            if (inplace){\n                this.__assign_properties(...other.__extract_properties());\n            }\n        }\n\n        set_column(columnName: string, values: CellValue[], inplace:boolean = false): DataFrame {\n            if (this.values.length != values.length) {\n                throw new RangeError(`DataFrame and Input Dimensions Don't Match\\nDataFrame has ${this.values.length} rows, while input values have ${values.length}`);\n            }\n            let dtype = detectColumn(values.map(row => row.toString()));\n            let output = this.copy()\n\n            if (!output.columns.includes(columnName)) {\n                output.columns.push(columnName);\n                output.__headers.add(columnName);\n            }\n\n            output.dtypes[columnName] = dtype;\n            for (let [row, index] of output.iterrows()) {\n                row[columnName] = values[index];\n            }\n\n            this.__assign_inplace(output,inplace);\n            return output;\n        }\n\n        to_array(headers: boolean = true): CellValue[][] {\n            /* Convert the values of the df into a 2D string|number|boolean array */\n            if (headers) {\n                return [this.columns, ...this.values.map(row => Object.values(row))];\n            }\n            else {\n                return this.values.map(row => Object.values(row))\n            }\n        }\n\n        private __check_membership(key: string) {\n            if (!(this.__headers.has(key))) {\n                throw RangeError(`Key: \"${key}\" not found in df.\\nDf Headers: ${this.columns}`);\n            }\n        }\n\n        private __check_numeric(column: string): number[] {\n            this.__check_membership(column);\n\n            const dtype = this.dtypes[column];\n            if (dtype !== \"number\") {\n                throw new TypeError(`Column \"${column}\" is not numeric. Detected type: \"${dtype}\"`);\n            }\n\n            return this.values\n                .map(row => row[column])\n                .filter(val => typeof val === \"number\") as number[];\n        }\n\n        private __extract_properties(): [string[], { [key: string]: (\"string\" | \"number\" | \"boolean\") }, Row[]] {\n            // Get all of the developer properties of the DataFrame\n            return [this.columns, this.dtypes, this.values];\n        }\n        private __assign_properties(columns: string[], dtypes: { [key: string]: (\"string\" | \"number\" | \"boolean\") }, values: Row[]) {\n            /* Manually overwrite all of the properties of the DataFrame */\n            this.columns = columns;\n            this.dtypes = dtypes;\n            this.values = values;\n            this.__headers = new Set(columns);\n        }\n\n        concat(other: DataFrame, columnSelection: (\"inner\" | \"outer\" | \"left\") = \"outer\"): DataFrame {\n            let other_cols = other.columns;\n\n            let columns: string[];\n            switch (columnSelection) {\n                case \"inner\":\n                    //List of columns is all shared columns;\n                    columns = this.columns.filter(col => other.__headers.has(col));\n                    break;\n                case \"outer\":\n                    let a = this.columns;\n                    let b = other.columns;\n\n                    //List of columns is all from a, then all from b that aren't in a.\n                    columns = a.concat(b.filter(col => !this.__headers.has(col)))\n                    break;\n                case \"left\":\n                    //List of columns is simply the columns in this df\n                    columns = this.columns;\n                    break;\n            }\n\n            // Helper to align rows to the unified column set\n            function alignRow(row: Row, columns: string[]): Row {\n                const aligned: Row = {};\n                for (const col of columns) {\n                    aligned[col] = row[col] ?? null; // Fill missing with null\n                }\n                return aligned;\n            }\n\n            const newData: Row[] = [\n                ...this.values.map(row => alignRow(row, columns)),\n                ...other.values.map(row => alignRow(row, columns)),\n            ];\n\n            // Convert back to array-of-arrays for constructor: [columns, ...rows]\n            const dataAsMatrix: (CellValue | null)[][] = [\n                columns,\n                ...newData.map(row => columns.map(col => row[col])),\n            ];\n\n            return new DataFrame(dataAsMatrix);\n        }\n\n        concat_all(columnSelection: \"inner\" | \"outer\" | \"left\" = \"outer\", ...others: DataFrame[]): DataFrame {\n            const all_dfs = [this, ...others];\n            let columnSet: string[];\n\n            // Resolve unified column set based on strategy\n            switch (columnSelection) {\n                case \"inner\":\n                    // Intersect headers across all DataFrames\n                    const shared = all_dfs.map(df => df.__headers);\n                    const intersection = shared.reduce((a, b) => {\n                        return new Set(Array.from(a).filter(x => b.has(x)));\n                    });\n\n                    // Preserve order from this.columns\n                    columnSet = this.columns.filter(col => intersection.has(col));\n                    break;\n                case \"outer\":\n                    const outerSet = new Set<string>();\n                    all_dfs.forEach(df => df.columns.forEach(col => outerSet.add(col)));\n                    columnSet = Array.from(outerSet);\n                    break;\n                case \"left\":\n                    columnSet = [...this.columns];\n                    break;\n            }\n\n            // Align a single row to unified columns\n            function alignRow(row: Row, columns: string[]): Row {\n                const aligned: Row = {};\n                for (const col of columns) {\n                    aligned[col] = row[col] !== undefined ? row[col] : null;\n                }\n                return aligned;\n            }\n\n            const end_size = all_dfs.reduce((sum, df) => sum + df.values.length, 0);\n\n            //Align all rows in the combined dfs\n            let allRows: Row[] = new Array(end_size);\n            \n            let rowIndex = 0;\n            for (const df of all_dfs) {\n                for (const row of df.values) {\n                    allRows[rowIndex++] = alignRow(row, columnSet);\n                }\n            }\n\n            // Build array-of-arrays for DataFrame constructor\n            const dataMatrix: (CellValue | null)[][] = [\n                columnSet,\n                ...allRows.map(row => columnSet.map(col => row[col]))\n            ];\n\n            return new DataFrame(dataMatrix);\n        }\n   \n\n        add_column(columnName: string, values: CellValue[] | CellValue, inplace:boolean = false): DataFrame {\n            let new_df = this.copy();\n\n            let inp_values: CellValue[];\n            if (Array.isArray(values)) {\n                if (values.length != this.values.length) {\n                    throw RangeError(`Length Mismatch:\\nSize of ${columnName} - ${values.length}\\nSize of df ${this.values.length}`);\n                }\n                inp_values = values;\n            }\n            else {\n                inp_values = Array(this.values.length).fill(values);\n            }\n\n            let old_size = new_df.__headers.size;\n            new_df.__headers.add(columnName)\n\n            if (new_df.__headers.size == old_size) {\n                throw RangeError(`Key \"${columnName}\" already in df`);\n            }\n            new_df.columns.push(columnName);\n            let dtype = detectColumn(inp_values as string[]);\n            new_df.dtypes[columnName] = dtype;\n\n            new_df.values.forEach((row, index) => {\n                row[columnName] = inp_values[index]\n            });\n\n            this.__assign_inplace(new_df,inplace);\n            return new_df;\n        }\n\n        copy(): DataFrame {\n            // Use JSON to force a deep copy\n            return new DataFrame(JSON.parse(JSON.stringify(this.to_array())));\n        }\n        shape(): [number, number] {\n            return [this.values.length, this.columns.length]\n        }\n\n        get_column(key: string): CellValue[] {\n            this.__check_membership(key);\n            return this.values.map(row => row[key]);\n        }\n\n        get_columns(...keys: string[]): DataFrame {\n            //Check that all keys are present in the df\n            keys.forEach(key => this.__check_membership(key));\n\n            let values = this.values.map(row => {\n                return keys.map(key => row[key]);\n            });\n\n            return new DataFrame([keys, ...values]);\n        }\n\n        drop(...columnsToDrop: string[]): DataFrame {\n            // Ensure all columns exist before proceeding\n            columnsToDrop.forEach(col => this.__check_membership(col));\n\n            // New columns excluding the dropped ones\n            const newColumns = this.columns.filter(col => !columnsToDrop.includes(col));\n\n            // New values excluding the dropped columns\n            const newValues = this.values.map(row => {\n                let newRow: Row = {};\n                newColumns.forEach(col => newRow[col] = row[col]); // Keep only selected columns\n                return newRow;\n            });\n\n            // Convert to DataFrame format\n            const resultData = [newColumns, ...newValues.map(row => newColumns.map(col => row[col]))];\n\n            return new DataFrame(resultData);\n        }\n\n        filter(key: string, predicate: (value: CellValue) => boolean): DataFrame {\n            // Check if the key exists in the dataframe\n            this.__check_membership(key);\n\n            // Filter rows based on the predicate function\n            const filteredValues = this.values.filter(row => predicate(row[key]));\n\n            // Create a new DataFrame with only the filtered rows\n            return new DataFrame([this.columns, ...filteredValues.map(row => this.columns.map(col => row[col]))]);\n        }\n\n        // 1. Count non-null values per column\n        count(column: string): number {\n            this.__check_membership(column);\n\n            return this.values.filter(row => row[column] !== null && row[column] !== undefined && row[column] !== \"\").length;\n        }\n\n        // 2. Sum of numeric column values\n        sum(column: string): number {\n            const values = this.__check_numeric(column);\n            return sum(values)\n        }\n\n        // 3. Mean (Average) of a numeric column\n        mean(column: string): number {\n            const values = this.__check_numeric(column);\n            return mean(values)\n        }\n\n        // Alias for mean\n        average(column: string): number {\n            return this.mean(column);\n        }\n\n        // 4. Minimum value in a numeric column\n        min(column: string): number {\n            const values = this.__check_numeric(column);\n            return min(values)\n        }\n\n        // 5. Maximum value in a numeric column\n        max(column: string): number {\n            const values = this.__check_numeric(column);\n            return max(values)\n        }\n\n        // 6. Standard Deviation in a numeric columns\n        std_dev(column: string, bessel: boolean = true): number {\n            const values = this.__check_numeric(column);\n            const n = values.length;\n            if (n <= 1) return NaN;\n\n            const mean = values.reduce((acc, val) => acc + val, 0) / n;\n            const divisor = bessel ? n - 1 : n;\n\n            return Math.sqrt(\n                values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / divisor\n            );\n        }\n\n        //7. Quantiles\n        quantile(column: string, q: number): number {\n            this.__check_numeric(column); // Ensure the column is numeric\n            const values = this.__check_numeric(column).sort((a, b) => a - b); // Sort values\n            const pos = (values.length - 1) * q / 100;\n            const base = Math.floor(pos);\n            const rest = pos - base;\n\n            if (values[base + 1] !== undefined) {\n                return values[base] + rest * (values[base + 1] - values[base]);\n            } else {\n                return values[base];\n            }\n        }\n\n        //8. Median\n        median(column: string): number {\n            return this.quantile(column, 50);\n        }\n\n        unique(...columns: string[]): DataFrame {\n            columns.forEach(c => this.__check_membership(c));\n\n            let combinations_seen = new Set();\n\n            let output: CellValue[][] = [];\n            for (let [row, index] of this.iterrows()) {\n                const combo = columns.map(c => row[c]);\n\n                let key = JSON.stringify(combo);\n\n                if (!combinations_seen.has(key)) {\n                    combinations_seen.add(key);\n                    output.push(combo);\n                }\n            }\n\n            return new DataFrame([columns, ...output]);\n        }\n\n        getNumericColumns(): string[] {\n            return this.columns.filter(col => this.dtypes[col] === \"number\");\n        }\n\n        describe(): DataFrame {\n            const numericCols = this.getNumericColumns();\n\n            const stats = [\n                \"Count\",\n                \"Mean\",\n                \"Standard Deviation\",\n                \"Minimum\",\n                \"1st Quartile\",\n                \"Median\",\n                \"3rd Quartile\",\n                \"Maximum\"\n            ];\n\n            const summaryMap: { [col: string]: (string | number)[] } = {};\n\n            for (let col of numericCols) {\n                summaryMap[col] = [];\n\n                for (let stat of stats) {\n                    switch (stat) {\n                        case \"Count\":\n                            summaryMap[col].push(this.count(col));\n                            break;\n                        case \"Mean\":\n                            summaryMap[col].push(this.mean(col));\n                            break;\n                        case \"Standard Deviation\":\n                            summaryMap[col].push(this.std_dev(col));\n                            break;\n                        case \"Minimum\":\n                            summaryMap[col].push(this.min(col));\n                            break;\n                        case \"1st Quartile\":\n                            summaryMap[col].push(this.quantile(col, 25));\n                            break;\n                        case \"Median\":\n                            summaryMap[col].push(this.median(col));\n                            break;\n                        case \"3rd Quartile\":\n                            summaryMap[col].push(this.quantile(col, 75));\n                            break;\n                        case \"Maximum\":\n                            summaryMap[col].push(this.max(col));\n                            break;\n                    }\n                }\n            }\n\n            const summaryRows: (string | number)[][] = [];\n\n            for (let col of numericCols) {\n                summaryRows.push([col, ...summaryMap[col]]);\n            }\n\n            return new DataFrame([\n                [\"Column\", ...stats],\n                ...summaryRows\n            ]);\n        }\n\n        groupBy(\n            group_keys: string[] | string,\n            valueCols: string[] | \"all\",\n            aggFuncs: (\"sum\" | \"mean\" | \"count\" | \"min\" | \"max\" | \"std_dev\")[] | (\"sum\" | \"mean\" | \"count\" | \"min\" | \"max\" | \"std_dev\")\n        ): DataFrame {\n            let keys: string[];\n            if (typeof (group_keys) == \"string\") {\n                keys = [group_keys]\n            }\n            else {\n                keys = group_keys;\n            }\n\n            keys.forEach(key => this.__check_membership(key));\n            keys.forEach(key => column_violates_separator(key));\n\n            let valueColumns: string[];\n            if (typeof (valueCols) == \"string\") {\n                valueColumns = this.getNumericColumns();\n                // Filter out any columns that are in the keys list\n                valueColumns = valueColumns.filter(col => !keys.includes(col));\n            }\n            else {\n                valueColumns = valueCols;\n            }\n\n            valueColumns.forEach(col => this.__check_membership(col));\n\n            // If only one aggFunc is provided, apply it to all valueColumns\n            if (typeof (aggFuncs) == \"string\") {\n                aggFuncs = new Array(valueColumns.length).fill(aggFuncs);\n            }\n            else if (aggFuncs.length === 1) {\n                aggFuncs = new Array(valueColumns.length).fill(aggFuncs[0]);\n            }\n\n\n            if (aggFuncs.length !== valueColumns.length) {\n                throw new Error(\n                    `Number of value columns (${valueColumns.length}) must match number of aggFuncs (${aggFuncs.length}), or only one aggFunc should be provided.`\n                );\n            }\n\n            const grouped: { [groupKey: string]: Row[] } = {};\n\n            for (let row of this.values) {\n                const groupKey = keys.map(k => row[k]).join(SEPARATOR);\n                if (!grouped[groupKey]) {\n                    grouped[groupKey] = [];\n                }\n                grouped[groupKey].push(row);\n            }\n\n            const aggregatedRows: CellValue[][] = [];\n            const resultHeaders: string[] = [...keys];\n\n            // Build output headers\n            valueColumns.forEach((col, idx) => {\n                resultHeaders.push(`${col}_${aggFuncs[idx]}`);\n            });\n\n            for (let groupKey in grouped) {\n                const rows = grouped[groupKey];\n                const groupDF = new DataFrame([\n                    this.columns,\n                    ...rows.map(r => this.columns.map(col => r[col])),\n                ]);\n\n                const keyParts = groupKey.split(SEPARATOR);\n                const aggregatedRow: CellValue[] = [...keyParts];\n\n                valueColumns.forEach((col, idx) => {\n                    const func = aggFuncs[idx];\n                    let value: number;\n\n                    switch (func) {\n                        case \"sum\":\n                            value = groupDF.sum(col);\n                            break;\n                        case \"mean\":\n                            value = groupDF.mean(col);\n                            break;\n                        case \"count\":\n                            value = groupDF.count(col);\n                            break;\n                        case \"min\":\n                            value = groupDF.min(col);\n                            break;\n                        case \"max\":\n                            value = groupDF.max(col);\n                            break;\n                        case \"std_dev\":\n                            value = groupDF.std_dev(col);\n                            break;\n                    }\n\n                    aggregatedRow.push(value);\n                });\n\n                aggregatedRows.push(aggregatedRow);\n            }\n\n            return new DataFrame([resultHeaders, ...aggregatedRows]);\n        }\n\n        query(condition: (row: Row) => boolean): DataFrame {\n            // Filter rows based on the provided condition function\n            const filteredValues = this.values.filter(row => condition(row));\n\n            // Convert filtered values into the DataFrame format\n            const resultData = [this.columns, ...filteredValues.map(row =>\n                this.columns.map(col => row[col])\n            )];\n\n            return new DataFrame(resultData);\n        }\n\n        isin(column: string, values: Set<CellValue>): DataFrame {\n            this.__check_membership(column); // make sure column exists\n\n            // Filter rows where the column's value is in the Set\n            const filteredRows = this.values.filter(row => values.has(row[column]));\n\n            // Rebuild data array for new DataFrame\n            const dataArray = [\n                this.columns,\n                ...filteredRows.map(row => this.columns.map(col => row[col]))\n            ];\n\n            return new DataFrame(dataArray);\n        }\n\n        sortBy(columns: string[], ascending: boolean[] = []): DataFrame {\n            // Ensure all columns exist in the DataFrame\n            columns.forEach(col => this.__check_membership(col));\n\n            // If only one sorting direction is provided, apply it to all columns\n            if (ascending.length === 1) {\n                ascending = Array(columns.length).fill(ascending[0]);\n            }\n\n            // Sort rows based on columns and their corresponding sort order (ascending or descending)\n            const sortedRows = [...this.values].sort((rowA, rowB) => {\n                for (let i = 0; i < columns.length; i++) {\n                    const col = columns[i];\n                    const direction = ascending[i] ? 1 : -1;\n                    if (rowA[col] < rowB[col]) return -direction;\n                    if (rowA[col] > rowB[col]) return direction;\n                }\n                return 0;\n            });\n\n            // Rebuild the data array for the new sorted DataFrame\n            const dataArray = [\n                this.columns,\n                ...sortedRows.map(row => this.columns.map(col => row[col]))\n            ];\n\n            return new DataFrame(dataArray);\n        }\n\n        merge(other: DataFrame, on: string[], how: \"inner\" | \"left\" | \"outer\" = \"inner\"): DataFrame {\n            // Ensure columns to join on exist in both DataFrames\n            on.forEach(col => {\n                this.__check_membership(col);\n                other.__check_membership(col);\n            });\n\n            // Join rows based on the selected `how` type\n            let mergedRows: Row[] = [];\n\n            switch (how) {\n                case \"inner\":\n                    // Perform an inner join (only matching rows)\n                    mergedRows = this.values.filter(row =>\n                        other.values.some(oRow => on.every(col => row[col] === oRow[col]))\n                    ).map(row => {\n                        const matchedRows = other.values.filter(oRow =>\n                            on.every(col => row[col] === oRow[col])\n                        );\n                        return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n                    });\n                    break;\n\n                case \"left\":\n                    // Perform a left join (all rows from the left DataFrame and matching rows from the right)\n                    mergedRows = this.values.map(row => {\n                        const matchedRows = other.values.filter(oRow =>\n                            on.every(col => row[col] === oRow[col])\n                        );\n                        return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n                    });\n                    break;\n\n                case \"outer\":\n                    // Perform an outer join (all rows from both DataFrames, matching where possible)\n                    mergedRows = [\n                        ...this.values.map(row => {\n                            const matchedRows = other.values.filter(oRow =>\n                                on.every(col => row[col] === oRow[col])\n                            );\n                            return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n                        }),\n                        ...other.values.filter(oRow =>\n                            !this.values.some(row =>\n                                on.every(col => row[col] === oRow[col])\n                            )\n                        )\n                    ];\n                    break;\n\n                default:\n                    throw new Error(\"Invalid join type. Use 'inner', 'left', or 'outer'.\");\n            }\n\n            // Combine the columns of both DataFrames, keeping the 'on' columns intact\n            const mergedColumns = [\n                ...this.columns, // Keep the columns from the left DataFrame\n                ...other.columns.filter(col => !on.includes(col)) // Exclude duplicate 'on' columns from the right DataFrame\n            ];\n\n            // Rebuild the data array for the new merged DataFrame\n            const dataArray = [\n                mergedColumns,\n                ...mergedRows.map(row => mergedColumns.map(col => row[col] || null)) // Handle any missing values\n            ];\n\n            return new DataFrame(dataArray);\n        }\n\n        iterrows(): [Row, number][] {\n            return this.values.map((row, idx) => [row, idx]);\n        }\n\n        to_json(headers: boolean = true): string {\n            return JSON.stringify(this.to_array(headers));\n        }\n\n        rename(columnsMap: { [oldName: string]: string }): DataFrame {\n            // Make sure all keys in columnsMap exist in the DataFrame\n            for (let oldCol in columnsMap) {\n                this.__check_membership(oldCol);\n            }\n\n            // Create new columns array by replacing old column names with new ones\n            const newColumns = this.columns.map(col => columnsMap[col] || col);\n\n            // Rebuild the data array with updated headers\n\n            return new DataFrame([newColumns, ...this.to_array(false)]);\n        }\n\n        add_formula_column(columnName: string, formula: string): DataFrame {\n            /* Append a table-style formula column\n            Example: [@Col1] + [@Col2]\n            */\n            let formula_col: string[] = Array(this.shape()[0]).fill(formula);\n            return this.add_column(columnName, formula_col);\n        }\n\n        fill_na(columnName: (string | string[] | \"ALL\"), method: (\"prev\" | \"next\" | \"value\"), value?: CellValue): DataFrame {\n            if (typeof columnName != \"string\" || columnName == \"ALL\") {\n                let columns: string[];\n                if (columnName == \"ALL\") {\n                    columns = this.columns;\n                }\n                else {\n                    columns = columnName;\n                }\n\n                let df = this.copy()\n                columns.forEach(c => df = df.fill_na(c, method, value));\n                return df;\n            }\n            else {\n                this.__check_membership(columnName);\n\n                //Deep copy before\n                let df = this.copy();\n\n                let replace_value: CellValue;\n                switch (method) {\n                    case \"prev\":\n                        let warnings: number[] = [];\n                        for (let [row, index] of df.iterrows()) {\n                            if (row[columnName] != \"\") {\n                                replace_value = row[columnName];\n                            }\n                            else {\n                                if (replace_value == null) {\n                                    warnings.push(index);\n                                }\n                                row[columnName] = replace_value;\n                            }\n                        }\n\n                        if (warnings.length > 0) {\n                            console.log(`WARNING: not all values were replaced (no header value to assign)\\nMissed values in rows: ${warnings}`);\n                        }\n                        break;\n                    case \"next\":\n                        let to_replace: number[] = [];\n                        for (let [row, index] of df.iterrows()) {\n                            if (row[columnName] == \"\") {\n                                to_replace.push(index);\n                            }\n                            else {\n                                replace_value = row[columnName];\n                                while (to_replace.length > 0) {\n                                    df.values[to_replace.pop()][columnName] = replace_value;\n                                }\n                            }\n                        }\n\n                        //If there are non-replaced values at the end of iteration log a warning\n                        if (to_replace.length > 0) {\n                            console.log(`WARNING: not all values were replaced (no bottom value to assign)\\nMissed values in rows: ${to_replace}`);\n                        }\n                        break;\n                    case \"value\":\n                        if (value == null) {\n                            throw new SyntaxError('If fillNa() method is \"value\" a value argument must be provided');\n                        }\n                        df.values.filter(row => row[columnName] == null).forEach(row => row[columnName] = value);\n                        break;\n                    default: throw new SyntaxError('fillNa() method must be \"prev\", \"next\", or \"value\"')\n                }\n                return df;\n            }\n        }\n\n        to_worksheet(worksheet: ExcelScript.Worksheet, method: (\"o\" | \"a\") = \"o\") {\n            //Include headers only when overwriting\n            let export_array: CellValue[][] = this.to_array(method == \"o\");\n            let export_range: ExcelScript.Range;\n            let [n_rows, n_cols] = this.shape();\n\n            //Overwrite logic\n            if (method == \"o\") {\n                //Overwrite the sheet\n                worksheet.getUsedRange()?.setValue(\"\");\n                //Get entire export range\n                export_range = worksheet.getRange(\"A1\").getResizedRange(n_rows, n_cols - 1)\n                //Import Just Headers for Property Table Initializations (with names)\n                let header_range = worksheet.getRange(\"A1\").getResizedRange(0, n_cols - 1);\n                header_range.setValues([this.columns]);\n                //Then try to set a table to the export range\n                try {\n                    worksheet.addTable(export_range, true);\n                }\n                catch {\n                    console.log(`A table already exists at ${export_range.getAddressLocal()}, proceeding anyways.`);\n                }\n            }\n            //Append logic\n            else if (method == \"a\") {\n                let used_rng = worksheet.getUsedRange();\n                if (used_rng == null) {\n                    //Recursively use overwrite logic if the appending sheet is empty\n                    return this.to_worksheet(worksheet, \"o\");\n                }\n                //Last row of the existing worksheet\n                let end_row = worksheet.getUsedRange().getLastRow()\n                //First cell of the import area\n                let start_rng = end_row.getOffsetRange(1, 0).getColumn(0);\n                export_range = start_rng.getResizedRange(n_rows - 1, n_cols - 1);\n            }\n            else {\n                throw new SyntaxError(\"Sheet export method must either be 'o' to overwrite or 'a' to append\")\n            }\n\n\n            //Import all values (including the headers again);\n            export_range.setValues(export_array);\n\n            //Print a helpful message if this export wasn't done as a helper method\n            if (worksheet.getName() != DEV_SHEET_NAME) {\n                console.log(`Dataframe Written to ${export_range.getAddressLocal()}`);\n            }\n            //*/\n        }\n\n        hardcode_formulas(workbook: ExcelScript.Workbook, inplace:boolean = true): DataFrame {\n            /*\n              Calculate and Hardcode all formula results in the input df. \n              Used to aggregate formula based calculations\n            */\n            let ExportSheet = workbook.addWorksheet(DEV_SHEET_NAME);\n            try{\n                this.to_worksheet(ExportSheet, 'o');\n            }\n            catch{\n                //Delete sheet after catching an error\n                ExportSheet.delete();\n                throw new SyntaxError(\"Error writing formulas to workbook. Likely incorrect formula syntax\");\n            }\n            \n            let calculated_df = fr.read_sheet(ExportSheet)\n            ExportSheet.delete();\n\n            if (inplace){\n                this.__assign_properties(...calculated_df.__extract_properties());\n            }\n            return calculated_df\n        }\n\n        to_csv(headers: boolean = true, separator: string = \",\"): string {\n            return this.to_array(headers).map(row => row.join(separator)).join(\"\\n\");\n        }\n\n        melt(newColumnName: string, newValueName: string, ...columns: string[]): DataFrame {\n            columns.forEach(col => this.__check_membership(col));\n\n            let cols_set = new Set(columns);\n            let other_cols = Array.from(this.__headers).filter(col => !cols_set.has(col));\n            let output_values: CellValue[][] = [[...other_cols, newColumnName, newValueName]];\n\n            for (let row of this.values) {\n                let other_vals = other_cols.map(col => row[col]);\n                columns.forEach(col => {\n                    let val = row[col]\n                    output_values.push([...other_vals, col, val]);\n                });\n            }\n            //console.log(output_values);\n            return new DataFrame(output_values);\n        }\n\n        melt_except(newColumnName: string, newValueName: string, ...exceptColumns: string[]): DataFrame {\n            exceptColumns.forEach(col => this.__check_membership(col));\n\n            let cols_set = new Set(exceptColumns);\n            let melt_cols = Array.from(this.__headers).filter(col => !cols_set.has(col));\n            return this.melt(newColumnName, newValueName, ...melt_cols);\n        }\n        \n        //General apply function, needs retyping\n        apply<T>(fn: (row: Row) => T): T[] {\n            return this.values.map(row => fn(row));\n        }\n\n        //Hidden typed apply function\n        private __apply_typed<T>(\n            fn: (row: { [key: string]: T }) => T,\n            caster: (v: CellValue) => T\n        ): T[] {\n            return this.values.map(original_row => {\n                const typed_row: { [key: string]: T } = {};\n                Object.entries(original_row).forEach(([key, value]) => {\n                    typed_row[key] = caster(value);\n                });\n                return fn(typed_row);\n            });\n        }\n\n        //Used typed apply to cast apply as Strings and Nubmers\n        apply_numeric(fn: (row: {[key:string]:number}) => number):number[]{\n            return this.__apply_typed(fn, Number);    \n        }\n        apply_string(fn: (row: {[key:string]:string}) => string):string[]{\n            return this.__apply_typed(fn,String);\n        }\n\n        map_cols_numeric(fn: (values: number[]) => number, ...columns:string[]):number[]{\n            //Check that all columns are in the df, and that they're numeric\n            columns.forEach(c =>{\n                this.__check_membership(c);\n                this.__check_numeric(c);\n            })\n\n            return this.values.map(row => {\n                const nums = columns.map(c => Number(row[c]));\n                return fn(nums);\n            })\n        }\n\n        drop_rows(...rows: number[]): DataFrame {\n            let df = this.copy();\n\n            let to_avoid = new Set(rows.map(row => {\n                if (row >= 0) { return row }\n                else {\n                    let adjusted = this.values.length + row;\n                    if (adjusted < 0) {\n                        throw new RangeError(`Not enough rows in DataFrame\\nInput ${row}, while df has ${this.values.length} rows`);\n                    }\n                    return adjusted;\n                }\n            }));\n\n            df.values = df.values.filter((_, index) => !to_avoid.has(index));\n            return df;\n        }\n\n        head(n_rows: number = 10): DataFrame {\n            if (this.values.length <= n_rows) { return this }\n            let df = this.copy();\n            df.values = this.values.slice(0, n_rows);\n            return df;\n        }\n\n        tail(n_rows: number = 10): DataFrame {\n            if (this.values.length <= n_rows) { return this }\n            let df = this.copy();\n            df.values = this.values.slice(this.values.length - n_rows);\n            return df;\n        }\n\n        print(n_rows: number = 5) {\n            const totalRows = this.values.length;\n            const headers = this.columns;\n\n            const headRows = this.head(n_rows).values;\n            const tailRows = this.tail(n_rows).values;\n\n            const rowsToPrint = totalRows <= n_rows * 2 ? this.values : [...headRows, \"...\", ...tailRows];\n\n            // Convert values to array of arrays for consistent handling\n            const dataArray = rowsToPrint.map(row => {\n                if (row === \"...\") return \"...\";\n                return headers.map(col => row[col] !== undefined ? String(row[col]) : \"\");\n            });\n\n            // Calculate column widths based on max length\n            const colWidths = headers.map((header, i) => {\n                const maxDataWidth = dataArray.reduce((max, row) => {\n                    if (row === \"...\") return max;\n                    return Math.max(max, row[i]?.length || 0);\n                }, header.length);\n                return maxDataWidth;\n            });\n\n            // Format header and divider\n            const pad = (text: string, width: number) => text.padEnd(width, \" \");\n            const headerRow = \"| \" + headers.map((h, i) => pad(h, colWidths[i])).join(\" | \") + \" |\";\n            const divider = \"| \" + colWidths.map(w => \"-\".repeat(w)).join(\" | \") + \" |\";\n\n            // Format data rows\n            const dataRows = dataArray.map(row => {\n                if (row === \"...\") {\n                    return \"| \" + colWidths.map(w => pad(\"...\", w)).join(\" | \") + \" |\";\n                } else {\n                    return \"| \" + row.map((val, i) => pad(val, colWidths[i])).join(\" | \") + \" |\";\n                }\n            });\n\n            let [number_of_df_rows, n_cols] = this.shape();\n            let size_statement = `(${number_of_df_rows} rows x ${n_cols} columns)`\n            console.log([headerRow, divider, ...dataRows, \"\", size_statement].join(\"\\n\"));\n        }\n\n        validate_key(key: DataFrame, on: [string, string] | string, errors: (\"raise\" | \"return\") = \"raise\"): CellValue[] | void {\n            let left_on: string;\n            let right_on: string;\n\n            if (typeof (on) == 'string') {\n                [left_on, right_on] = [on, on];\n            }\n            else {\n                [left_on, right_on] = on;\n            }\n\n            this.__check_membership(left_on);\n            key.__check_membership(right_on);\n\n            let left_values = this.get_column(left_on);\n            let right_values = new Set(key.get_column(right_on));\n\n            let not_in_key = left_values.filter(v => !right_values.has(v));\n\n            if (not_in_key.length != 0) {\n                if (errors == \"raise\") {\n                    throw new Error(`KeyIncompleteError: The following values were not found in the selected key\\n[${not_in_key.join(',')}]`)\n                }\n                else {\n                    return not_in_key;\n                }\n            }\n        }\n\n        __overwrite_to_table(table: ExcelScript.Table) {\n            let table_rng = table.getRange();\n            let n_table_rows = Number(table_rng.getLastRow().getEntireRow().getAddress().split(\":\")[1]) - 1;\n            let n_table_cols = table.getHeaderRowRange().getValues()[0].length;\n\n            let [n_df_rows, n_df_cols] = this.shape();\n\n            //Delete excess table columns\n            if (n_table_cols > n_df_cols) {\n                let diff = n_df_cols - n_table_cols + 1 //Add one for column resizing\n                let last_col = table_rng.getLastColumn();\n\n                let delete_rng = last_col.getResizedRange(0, diff);\n\n                console.log(`Existing Table Has Too Many Columns. Deleting Range: ${delete_rng.getAddressLocal()}`);\n                delete_rng.delete(ExcelScript.DeleteShiftDirection.left);\n                table_rng = table.getRange();\n            }\n            //Delete excess table rows\n            if (n_table_rows > n_df_rows) {\n                let diff = n_df_rows - n_table_rows + 1;\n                let last_row = table_rng.getLastRow();\n\n                let delete_rng = last_row.getResizedRange(diff, 0);\n\n                console.log(`Existing Table Has Too Many Rows. Deleting Range: ${delete_rng.getAddressLocal()}`);\n                delete_rng.delete(ExcelScript.DeleteShiftDirection.up);\n                table_rng = table.getRange();\n            }\n\n            //Get the starting point of the table\n            let table_start = table_rng.getCell(0, 0);\n            let overwrite_vals = this.to_array(true);\n\n            table_start.getResizedRange(n_df_rows, n_df_cols - 1).setValues(overwrite_vals);\n        }\n\n        __append_to_table(table: ExcelScript.Table) {\n            let rng = table.getRange();\n            let first_cell = rng.getLastRow().getCell(0, 0).getOffsetRange(1, 0);\n\n            //Mapping onto new table logic\n            let headers = table.getHeaderRowRange().getValues()[0] as string[];\n            let header_set = new Set(headers);\n\n            let not_found_in_df = headers.filter(h => !(this.__headers.has(h)));\n            let not_found_in_table = this.columns.filter(c => !(header_set.has(c)));\n\n            if (not_found_in_df.length > 0) {\n                console.log(`Table Headers not found in DataFrame: ${not_found_in_df}. Filling Values with null...`);\n            }\n            if (not_found_in_table.length > 0) {\n                console.log(`Dataframe headers not found in table ${not_found_in_table}. Dropping values to append...`);\n            }\n\n\n            let new_values = this.values.map((row, idx) => {\n                return headers.map(h => row[h]) //Map all of the headers onto the new DataFrame\n            })\n\n            first_cell.getResizedRange(new_values.length - 1, new_values[0].length - 1).setValues(new_values);\n        }\n\n        to_table(table: ExcelScript.Table, method: ('o' | 'a')) {\n            switch (method) {\n                case 'o': return this.__overwrite_to_table(table);\n                case 'a': return this.__append_to_table(table);\n                default: throw new SyntaxError(\"Table write method must either be 'o' (overwrite), or 'a' (append).\")\n            }\n        }\n    }\n}\n\nfunction main(workbook: ExcelScript.Workbook) {\n    // See full documentation at: https://joeyrussoniello.github.io/frosts/\n\n    //YOUR CODE GOES HERE\n}\n","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}