{"version":"0.3.0","body":"namespace frosts{\n  function detectTypeFromString(s: string): string {\n    if (!s) {\n      s = \"\";\n    }\n    s = s.toString();\n    if (!(isNaN(parseFloat(s))) || s == \"\") {\n      return \"number\"\n    }\n    if (['true', 'false'].includes(s.toLocaleLowerCase())) {\n      return \"boolean\"\n    }\n    else {\n      return \"string\"\n    }\n  }\n  function detectColumn(col: string[]): string {\n    // Detect the type of each value in the column\n    let types = col.map(i => detectTypeFromString(i));\n\n    // Check if all types are the same\n    const uniqueTypes = Array.from(new Set(types));\n\n    // If there's only one unique type, return that type; otherwise, return \"string\"\n    if (uniqueTypes.length === 1) {\n      return uniqueTypes[0];\n    } else {\n      return \"string\";\n    }\n  }\n  export function df_from_range(range: ExcelScript.Range): DataFrame {\n    return new DataFrame(range.getValues());\n  }\n  export function df_from_sheet(Sheet: ExcelScript.Worksheet): DataFrame {\n    let rng = Sheet.getUsedRange();\n    return df_from_range(rng);\n  }\n  export function write_df_to_sheet(df: DataFrame, workbook: ExcelScript.Workbook, sheet_name: string = \"DataFrame\", reset_sheet: boolean = true, to_table: boolean = true, start_cell: string = \"A1\") {\n    let Sheet = workbook.getWorksheet(sheet_name);\n    if (!Sheet) {\n      Sheet = workbook.addWorksheet(sheet_name)\n    }\n\n    if (reset_sheet){\n      Sheet.getUsedRange()?.setValue(\"\");\n    }\n    const arr = df.__array();\n    let [n_rows, n_cols] = df.shape();\n    let import_range = Sheet.getRange(start_cell).getResizedRange(n_rows - 1, n_cols - 1)\n    import_range.setValues(arr);\n\n    if (to_table){\n      let table = Sheet.addTable(import_range,true);\n    }\n    console.log(`Dataframe Written to ${import_range.getAddressLocal()}`);\n  }\n  type Row = { [key: string]: string | number | boolean };\n  export class DataFrame {\n    columns: string[]\n    __headers: Set<String>\n    dtypes: { [key: string]: string }\n    values: Row[];\n\n    constructor(data: (string | number | boolean)[][]) {\n      let str_data = data as string[][];\n      let headers = str_data[0];\n      str_data = str_data.slice(1);\n      this.dtypes = {};\n      headers.forEach((header, col_idx) => {\n        this.dtypes[header] = detectColumn(str_data.map(row => row[col_idx]))\n      });\n\n      //CHECK FOR DUPLICATE HEADERS\n      let set_headers = new Set(headers);\n      if (headers.length! - set_headers.size) {\n        throw new SyntaxError(\"Duplicate Headers found\");\n      }\n\n      this.columns = headers;\n      this.__headers = set_headers;\n\n      this.values = []\n      for (let row of str_data) {\n        let row_values: Row = {};\n        headers.forEach((header, i) => row_values[header] = row[i]);\n        this.values.push(row_values);\n      }\n    }\n\n    __array(): (string | number | boolean)[][] {\n      return [this.columns, ...this.values.map(row => Object.values(row))];\n    }\n\n    __check_membership(key: string) {\n      if (!(this.__headers.has(key))) {\n        throw RangeError(`Key: \"${key}\" not found in df.`);\n      }\n    }\n\n    __check_numeric(column: string): number[] {\n      this.__check_membership(column);\n\n      const dtype = this.dtypes[column];\n      if (dtype !== \"number\") {\n        throw new TypeError(`Column \"${column}\" is not numeric. Detected type: \"${dtype}\"`);\n      }\n\n      return this.values\n        .map(row => row[column])\n        .filter(val => typeof val === \"number\") as number[];\n    }\n\n    add_column(columnName:string, values:(string|number|boolean)[]):DataFrame{\n      if (values.length != this.values.length){\n        throw RangeError(`Length Mismatch:\\nSize of ${columnName} - ${values.length}\\nSize of df ${this.values.length}`);\n      }\n\n      let new_df = this.copy();\n      let old_size = new_df.__headers.size;\n      new_df.__headers.add(columnName)\n\n      if (new_df.__headers.size == old_size){\n        throw RangeError(`Key \"${columnName}\" already in df`);\n      }\n\n      new_df.columns.push(columnName);\n      let dtype = detectColumn(values as string[]);\n      new_df.dtypes[columnName] = dtype;\n\n      new_df.values.map((row, index) => {\n        row[columnName] = values[index]\n      });\n\n      return new_df;\n    }\n\n    copy(): DataFrame {\n      // Create a deep copy of all necessary internal data structures\n      let new_values:(string|number|boolean)[][] = JSON.parse(JSON.stringify(this.values)); // Deep copy of values\n      let new_columns = [...this.columns]; // Shallow copy of columns (array is simple)\n\n      // Create a new DataFrame using the copied structures\n      return new DataFrame([new_columns,...new_values]);\n    }\n    shape(): [number, number] {\n      return [this.values.length + 1, this.columns.length]\n    }\n\n    get_columns(...keys: string[]): DataFrame {\n      //Check that all keys are present in the df\n      keys.forEach(key => this.__check_membership(key));\n\n      let values = this.values.map(row => {\n        return keys.map(key => row[key]);\n      });\n\n      return new DataFrame([keys, ...values]);\n    }\n\n    drop(...columnsToDrop: string[]): DataFrame {\n      // Ensure all columns exist before proceeding\n      columnsToDrop.forEach(col => this.__check_membership(col));\n\n      // New columns excluding the dropped ones\n      const newColumns = this.columns.filter(col => !columnsToDrop.includes(col));\n\n      // New values excluding the dropped columns\n      const newValues = this.values.map(row => {\n        let newRow: Row = {};\n        newColumns.forEach(col => newRow[col] = row[col]); // Keep only selected columns\n        return newRow;\n      });\n\n      // Convert to DataFrame format\n      const resultData = [newColumns, ...newValues.map(row => newColumns.map(col => row[col]))];\n\n      return new DataFrame(resultData);\n    }\n\n    filter(key: string, predicate: (value: string | number | boolean) => boolean): DataFrame {\n      // Check if the key exists in the dataframe\n      this.__check_membership(key);\n\n      // Filter rows based on the predicate function\n      const filteredValues = this.values.filter(row => predicate(row[key]));\n\n      // Create a new DataFrame with only the filtered rows\n      return new DataFrame([this.columns, ...filteredValues.map(row => this.columns.map(col => row[col]))]);\n    }\n\n    // 1. Count non-null values per column\n    count(column: string): number {\n      this.__check_membership(column);\n\n      return this.values.filter(row => row[column] !== null && row[column] !== undefined && row[column] !== \"\").length;\n    }\n\n    // 2. Sum of numeric column values\n    sum(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.reduce((acc, val) => acc + val, 0);\n    }\n\n    // 3. Mean (Average) of a numeric column\n    mean(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.length > 0 ? this.sum(column) / values.length : NaN;\n    }\n\n    // Alias for mean\n    average(column: string): number {\n      return this.mean(column);\n    }\n\n    // 4. Minimum value in a numeric column\n    min(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.length > 0 ? Math.min(...values) : NaN;\n    }\n\n    // 5. Maximum value in a numeric column\n    max(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.length > 0 ? Math.max(...values) : NaN;\n    }\n\n    // 6. Standard Deviation in a numeric columns\n    std_dev(column: string, bessel: boolean = true): number {\n      const values = this.__check_numeric(column);\n      const n = values.length;\n      if (n <= 1) return NaN;\n\n      const mean = values.reduce((acc, val) => acc + val, 0) / n;\n      const divisor = bessel ? n - 1 : n;\n\n      return Math.sqrt(\n        values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / divisor\n      );\n    }\n\n    //7. Quantiles\n    quantile(column: string, q: number): number {\n      this.__check_numeric(column); // Ensure the column is numeric\n      const values = this.__check_numeric(column).sort((a, b) => a - b); // Sort values\n      const pos = (values.length - 1) * q/100;\n      const base = Math.floor(pos);\n      const rest = pos - base;\n\n      if (values[base + 1] !== undefined) {\n        return values[base] + rest * (values[base + 1] - values[base]);\n      } else {\n        return values[base];\n      }\n    }\n\n    //8. Median\n    median(column:string): number{\n      return this.quantile(column, 50);\n    }\n\n    unique(column:string): (string|number|boolean)[]{\n      this.__check_membership(column);\n\n      return Array.from(new Set(this.values.map(row => row[column])));\n    }\n    getNumericColumns(): string[] {\n      return this.columns.filter(col => this.dtypes[col] === \"number\");\n    }\n\n    describe(): DataFrame {\n      const numericCols = this.getNumericColumns();\n\n      const stats = [\"Count\", \"Mean\", \"Standard Deviation\", \"Minimum\",\"1st Quartile\",\"Median\",\"3rd Quartile\",\"Maximum\"];\n\n      const summaryRows: (string | number)[][] = [];\n\n      for (let stat of stats) {\n        const row: (string | number)[] = [stat];\n\n        for (let col of numericCols) {\n          switch (stat) {\n            case \"Count\":\n              row.push(this.count(col));\n              break;\n            case \"Mean\":\n              row.push(this.mean(col));\n              break;\n            case \"Standard Deviation\":\n              row.push(this.std_dev(col));\n              break;\n            case \"Minimum\":\n              row.push(this.min(col));\n              break;\n            case \"Maximum\":\n              row.push(this.max(col));\n              break;\n            \n            case \"1st Quartile\":\n              row.push(this.quantile(col,25));\n            case \"Median\": \n              row.push(this.median(col));\n            case \"3rd Quartile\":\n              row.push(this.quantile(col,75));\n          }\n        }\n\n        summaryRows.push(row);\n      }\n\n      return new DataFrame([\n        [\"Column:\", ...numericCols],\n        ...summaryRows\n      ]);\n    }\n\n    groupBy(\n      group_keys: string[] | string,\n      valueCols: string[] | \"all\",\n      aggFuncs: (\"sum\" | \"mean\" | \"count\" | \"min\" | \"max\" | \"std_dev\")[] | (\"sum\" | \"mean\" | \"count\" | \"min\" | \"max\" | \"std_dev\")\n    ): DataFrame {\n      let keys: string[];\n      if (typeof (group_keys) == \"string\") {\n        keys = [group_keys]\n      }\n      else {\n        keys = group_keys;\n      }\n\n      keys.forEach(key => this.__check_membership(key));\n\n      let valueColumns: string[];\n      if (typeof (valueCols) == \"string\") {\n        valueColumns = this.getNumericColumns();\n        // Filter out any columns that are in the keys list\n        valueColumns = valueColumns.filter(col => !keys.includes(col));\n      }\n      else {\n        valueColumns = valueCols;\n      }\n\n      valueColumns.forEach(col => this.__check_membership(col));\n\n      // If only one aggFunc is provided, apply it to all valueColumns\n      if (typeof (aggFuncs) == \"string\") {\n        aggFuncs = new Array(valueColumns.length).fill(aggFuncs);\n      }\n      else if (aggFuncs.length === 1) {\n        aggFuncs = new Array(valueColumns.length).fill(aggFuncs[0]);\n      }\n\n\n      if (aggFuncs.length !== valueColumns.length) {\n        throw new Error(\n          `Number of value columns (${valueColumns.length}) must match number of aggFuncs (${aggFuncs.length}), or only one aggFunc should be provided.`\n        );\n      }\n\n      const grouped: { [groupKey: string]: Row[] } = {};\n\n      for (let row of this.values) {\n        const groupKey = keys.map(k => row[k]).join(\"||\");\n        if (!grouped[groupKey]) {\n          grouped[groupKey] = [];\n        }\n        grouped[groupKey].push(row);\n      }\n\n      const aggregatedRows: (string | number | boolean)[][] = [];\n      const resultHeaders: string[] = [...keys];\n\n      // Build output headers\n      valueColumns.forEach((col, idx) => {\n        resultHeaders.push(`${col}_${aggFuncs[idx]}`);\n      });\n\n      for (let groupKey in grouped) {\n        const rows = grouped[groupKey];\n        const groupDF = new DataFrame([\n          this.columns,\n          ...rows.map(r => this.columns.map(col => r[col])),\n        ]);\n\n        const keyParts = groupKey.split(\"||\");\n        const aggregatedRow: (string | number | boolean)[] = [...keyParts];\n\n        valueColumns.forEach((col, idx) => {\n          const func = aggFuncs[idx];\n          let value: number;\n\n          switch (func) {\n            case \"sum\":\n              value = groupDF.sum(col);\n              break;\n            case \"mean\":\n              value = groupDF.mean(col);\n              break;\n            case \"count\":\n              value = groupDF.count(col);\n              break;\n            case \"min\":\n              value = groupDF.min(col);\n              break;\n            case \"max\":\n              value = groupDF.max(col);\n              break;\n            case \"std_dev\":\n              value = groupDF.std_dev(col);\n              break;\n          }\n\n          aggregatedRow.push(value);\n        });\n\n        aggregatedRows.push(aggregatedRow);\n      }\n\n      return new DataFrame([resultHeaders, ...aggregatedRows]);\n    }\n\n    operateColumns(operator:(\"*\" | \"+\" | \"-\" | \"/\"), col1: string, col2: string):number[]{\n      // Check if both columns exist\n      this.__check_membership(col1);\n      this.__check_membership(col2);\n\n      // Ensure the columns are numeric\n      let nums1 = this.__check_numeric(col1);\n      let nums2 = this.__check_numeric(col2);\n\n      // Create the new values array by dividing values of col1 and col2\n      const transformedValues = nums1.map((n1, i) => {\n        let n2 = nums2[i];\n        switch (operator){\n          case \"+\": return n1 + n2\n          case \"-\": return n1 - n2\n          case \"*\": return n1 * n2\n          case \"/\": return n1 / n2\n        }\n      })\n      return transformedValues\n    }\n\n\n    query(condition: (row: Row) => boolean): DataFrame {\n      // Filter rows based on the provided condition function\n      const filteredValues = this.values.filter(row => condition(row));\n\n      // Convert filtered values into the DataFrame format\n      const resultData = [this.columns, ...filteredValues.map(row =>\n        this.columns.map(col => row[col])\n      )];\n\n      return new DataFrame(resultData);\n    }\n\n    isin(column: string, values: Set<string | number | boolean>): DataFrame {\n      this.__check_membership(column); // make sure column exists\n\n      // Filter rows where the column's value is in the Set\n      const filteredRows = this.values.filter(row => values.has(row[column]));\n\n      // Rebuild data array for new DataFrame\n      const dataArray = [\n        this.columns,\n        ...filteredRows.map(row => this.columns.map(col => row[col]))\n      ];\n\n      return new DataFrame(dataArray);\n    }\n\n    sortBy(columns: string[], ascending: boolean[] = []): DataFrame {\n      // Ensure all columns exist in the DataFrame\n      columns.forEach(col => this.__check_membership(col));\n\n      // If only one sorting direction is provided, apply it to all columns\n      if (ascending.length === 1) {\n        ascending = Array(columns.length).fill(ascending[0]);\n      }\n\n      // Sort rows based on columns and their corresponding sort order (ascending or descending)\n      const sortedRows = [...this.values].sort((rowA, rowB) => {\n        for (let i = 0; i < columns.length; i++) {\n          const col = columns[i];\n          const direction = ascending[i] ? 1 : -1;\n          if (rowA[col] < rowB[col]) return -direction;\n          if (rowA[col] > rowB[col]) return direction;\n        }\n        return 0;\n      });\n\n      // Rebuild the data array for the new sorted DataFrame\n      const dataArray = [\n        this.columns,\n        ...sortedRows.map(row => this.columns.map(col => row[col]))\n      ];\n\n      return new DataFrame(dataArray);\n    }\n\n    merge(other: DataFrame, on: string[], how: \"inner\" | \"left\" | \"outer\" = \"inner\"): DataFrame {\n      // Ensure columns to join on exist in both DataFrames\n      on.forEach(col => {\n        this.__check_membership(col);\n        other.__check_membership(col);\n      });\n\n      // Join rows based on the selected `how` type\n      let mergedRows: Row[] = [];\n\n      switch (how) {\n        case \"inner\":\n          // Perform an inner join (only matching rows)\n          mergedRows = this.values.filter(row =>\n            other.values.some(oRow => on.every(col => row[col] === oRow[col]))\n          ).map(row => {\n            const matchedRows = other.values.filter(oRow =>\n              on.every(col => row[col] === oRow[col])\n            );\n            return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n          });\n          break;\n\n        case \"left\":\n          // Perform a left join (all rows from the left DataFrame and matching rows from the right)\n          mergedRows = this.values.map(row => {\n            const matchedRows = other.values.filter(oRow =>\n              on.every(col => row[col] === oRow[col])\n            );\n            return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n          });\n          break;\n\n        case \"outer\":\n          // Perform an outer join (all rows from both DataFrames, matching where possible)\n          mergedRows = [\n            ...this.values.map(row => {\n              const matchedRows = other.values.filter(oRow =>\n                on.every(col => row[col] === oRow[col])\n              );\n              return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n            }),\n            ...other.values.filter(oRow =>\n              !this.values.some(row =>\n                on.every(col => row[col] === oRow[col])\n              )\n            )\n          ];\n          break;\n\n        default:\n          throw new Error(\"Invalid join type. Use 'inner', 'left', or 'outer'.\");\n      }\n\n      // Combine the columns of both DataFrames, keeping the 'on' columns intact\n      const mergedColumns = [\n        ...this.columns, // Keep the columns from the left DataFrame\n        ...other.columns.filter(col => !on.includes(col)) // Exclude duplicate 'on' columns from the right DataFrame\n      ];\n\n      // Rebuild the data array for the new merged DataFrame\n      const dataArray = [\n        mergedColumns,\n        ...mergedRows.map(row => mergedColumns.map(col => row[col] || null)) // Handle any missing values\n      ];\n\n      return new DataFrame(dataArray);\n    }\n\n    to_json():string{\n      return JSON.stringify(this.__array());\n    }\n  }\n}\n\nfunction main(workbook: ExcelScript.Workbook) {\n  //YOUR CODE GOES HERE\n\n  /* EXAMPLE CODE:\n  let sheet = workbook.getActiveWorksheet();\n  let df = frosts.df_from_sheet(sheet);\n  \n  frosts.write_df_to_sheet(df.describe(), workbook, \"New Worksheet\"); //Save decription to New Worksheet\n  */\n}\n\n","description":"","noCodeMetadata":null,"parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}