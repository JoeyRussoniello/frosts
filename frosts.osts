{"version":"0.3.0","body":"namespace frosts{\n  //DEFAULT SEPARATOR FOR MULTIPLE JOINS\n  let SEPARATOR = \"~~~\";\n  //ABSTRACT DEV SHEET NAME FOR FORMULA HARDCODING\n  const DEV_SHEET_NAME = \"___DEV_SHEET_NULL\";\n\n  export function get_separator():string{\n    return SEPARATOR;\n  }\n  export function set_separator(separator:string){\n    SEPARATOR = separator;\n  }\n\n  //Helper function for DataFrame Initialization\n  function column_violates_separator(key:string){\n    if (key.includes(get_separator())){\n      throw new Error(`Input key: ${key} contains the interal frost separator ${get_separator()}, this may cause unintended behavior. \\n Please modify the column name using df.rename(), or the separator value using the frosts.set_separator()`);\n    }\n  }\n\n  function detectTypeFromString(s: string): (\"string\"|\"number\"|\"boolean\") {\n    if (!s) {\n      s = \"\";\n    }\n    s = s.toString();\n    if (/^-?\\d+(\\.\\d+)?$/.test(s) || s == \"\") {\n      return \"number\";\n    }\n    if (['true', 'false'].includes(s.toLocaleLowerCase())) {\n      return \"boolean\"\n    }\n    else {\n      return \"string\"\n    }\n  }\n  function detectColumn(col: string[]): (\"string\"|\"number\"|\"boolean\") {\n    // Detect the type of each value in the column\n    let types = col.map(i => detectTypeFromString(i));\n\n    // Check if all types are the same\n    const uniqueTypes = Array.from(new Set(types));\n\n    // If there's only one unique type, return that type; otherwise, return \"string\"\n    if (uniqueTypes.length === 1) {\n      return uniqueTypes[0];\n    } else {\n      return \"string\";\n    }\n  }\n  function parseValue(input:string|number|boolean,parse_method:(\"string\"|\"number\"|\"boolean\")):string|number|boolean{\n    switch (parse_method){\n      case \"string\": return input.toString();\n      case \"boolean\": return input.toString() == \"true\";\n      case \"number\": return parseFloat(input.toString());\n      default: throw SyntaxError(\"Error parsing value: parsing method must be either 'string','boolean',or 'number'\");\n    }\n  }\n  export function read_range(range: ExcelScript.Range): DataFrame {\n    return new DataFrame(range.getValues());\n  }\n  export function read_sheet(Sheet: ExcelScript.Worksheet): DataFrame {\n    let rng = Sheet.getUsedRange();\n    if (!rng){\n      throw new Error(`Input Sheet \"${Sheet.getName()}\" is empty, unable to create DataFrame`);\n    }\n    return read_range(rng);\n  }\n\n  export function read_json(json:string):DataFrame{\n    /* Parse an input JSON-coded string to create a DataFrame*/\n      return new DataFrame(JSON.parse(json))\n  }\n\n  export function read_after(Sheet:ExcelScript.Worksheet, n_rows:number, n_cols:number){\n    let rng = Sheet.getUsedRange();\n    let new_rng = rng.getOffsetRange(n_rows,n_cols).getUsedRange();\n    return read_range(new_rng);\n  }\n\n  //Helper function for CSV parsing Fixes occurences like \"1,024\"\n  function remove_chars_within_quotes(longtext: string): string {\n    //Removes line breaks and commas within quotes using a stack, runs in O(n) space and memory\n    let stklen = 0;\n    let newstring = \"\"\n    for (let i = 0; i < longtext.length; i++) {\n      let char = longtext[i];\n      //Stack counter to determine whether we are inside double quotes\n      if (char == '\"') {\n        if (stklen == 0) {\n          stklen = 1;\n        }\n        else {\n          stklen = 0;\n        }\n        newstring += \"\"\n      }\n      //If we are in quotes, these are problem characters.\n      else if (stklen == 1 && (char == \"\\n\" || char == \",\")) {\n        if (char == \",\") {\n          newstring += \"\"\n        }\n        if (char == \"\\n\") {\n          newstring += \" \"\n        }\n      }\n      else {\n        newstring += char\n      }\n    }\n    return newstring\n  }\n\n  export function read_csv(input_text: string, errors: (\"raise\" | \"coerce\") = \"raise\",start_index: number=0, line_separator:string = \"\\n\"): DataFrame {\n    let cleaned_text = remove_chars_within_quotes(input_text);\n    let line_split_arr: string[] = [];\n    //Determine splitting method, then split\n    if (cleaned_text.includes(line_separator)) {\n      line_split_arr = cleaned_text.split(line_separator);\n    }\n    else {\n      console.log(`No split marker in ${cleaned_text}`);\n    }\n\n    let output: string[][] = line_split_arr.map(row => row.split(\",\"))\n\n    //Find sizes and reshape array to ensure that the input is square and importable\n    \n    const maxLength = output.reduce((max, row) => Math.max(max, row.length), 0);\n    output.forEach(row => {\n      if(row.length != maxLength){\n        if (errors==\"raise\"){\n          throw new TypeError(\"Error in CSV parsing. Rows are not all the same size. This may cause unintended behavior\\nIf this is intentional, use errors='coerce'\");\n        }\n        else{\n          while (row.length < maxLength) {\n            row.push(null);\n          }\n        }\n      }\n    });\n\n    return new DataFrame(output.slice(start_index));\n  }\n\n  export function to_numeric(column:(string|number|boolean)[]):number[]{\n    return column.map(row => parseFloat(row.toString()));\n  }\n\n  export type Row = { [key: string]: string | number | boolean };\n\n  export class DataFrame {\n    columns: string[]\n    __headers: Set<string>\n    dtypes: { [key: string]: (\"string\"|\"number\"|\"boolean\") }\n    values: Row[];\n\n    constructor(data: (string | number | boolean)[][]) {\n      let str_data = data as string[][];\n      let headers = str_data[0];\n\n      // Remove columns with blank headers\n      let validHeaders = headers.filter(header => header !== \"\" && header !== null && header !== undefined);\n\n      // If there are any blank columns, remove the corresponding columns from the data\n      let validColumnsData = str_data.map(row => row.filter((_, i) => headers[i] !== \"\" && headers[i] !== null && headers[i] !== undefined));\n\n      str_data = validColumnsData.slice(1);  // Remove the first row (headers) from data\n\n      // If no valid headers exist, throw an error\n      if (validHeaders.length === 0) {\n        throw new SyntaxError(\"No valid headers found.\");\n      }\n\n      this.dtypes = {};\n\n      // Check for duplicate headers\n      let set_headers = new Set(validHeaders);\n      if (validHeaders.length !== set_headers.size) {\n        throw new SyntaxError(`Duplicate Headers found:\\n${validHeaders}`);\n      }\n\n      this.columns = validHeaders;\n      this.__headers = set_headers;\n\n      this.values = [];\n      for (let row of str_data) {\n        let row_values: Row = {};\n        validHeaders.forEach((header, i) => row_values[header] = row[i]);\n        this.values.push(row_values);\n      }\n\n      // Enforce type security\n      validHeaders.forEach((header, col_idx) => {\n        this.dtypes[header] = detectColumn(str_data.map(row => row[col_idx]));\n        if (this.dtypes[header] !== \"string\" && this.values.length > 0 && typeof (this.values[0][header]) === \"string\") {\n          // Correct data type if needed\n          this.values.map(row => row[header] = parseValue(row[header], this.dtypes[header]));\n        }\n      });\n    }\n\n\n    set_column(columnName:string, values:(string|number|boolean)[]):DataFrame{\n      if(this.values.length != values.length){\n        throw new RangeError(`DataFrame and Input Dimensions Don't Match\\nDataFrame has ${this.values.length} rows, while input values have ${values.length}`);\n      }\n      let dtype = detectColumn(values.map(row => row.toString()));\n      let output = this.copy()\n\n      if (!output.columns.includes(columnName)){\n        output.columns.push(columnName);\n        output.__headers.add(columnName);\n      }\n\n      output.dtypes[columnName] = dtype;\n      for (let [row, index] of output.iterrows()){\n        row[columnName] = values[index];\n      }\n      return output;\n    }\n    \n    to_array(headers: boolean = true): (string | number | boolean)[][] {\n      /* Convert the values of the df into a 2D string|number|boolean array */\n      if (headers){\n        return [this.columns, ...this.values.map(row => Object.values(row))];\n      }\n      else{\n        return this.values.map(row => Object.values(row))\n      }\n    }\n\n    __check_membership(key: string) {\n      if (!(this.__headers.has(key))) {\n        throw RangeError(`Key: \"${key}\" not found in df.\\nDf Headers: ${this.columns}`);\n      }\n    }\n\n    __check_numeric(column: string): number[] {\n      this.__check_membership(column);\n\n      const dtype = this.dtypes[column];\n      if (dtype !== \"number\") {\n        throw new TypeError(`Column \"${column}\" is not numeric. Detected type: \"${dtype}\"`);\n      }\n\n      return this.values\n        .map(row => row[column])\n        .filter(val => typeof val === \"number\") as number[];\n    }\n\n    __extract_properties():[string[], {[key:string]:(\"string\"|\"number\"|\"boolean\")}, Row[]]{\n      // Get all of the developer properties of the DataFrame\n      return [this.columns, this.dtypes, this.values];\n    }\n    __assign_properties(columns:string[], dtypes:{[key:string]:(\"string\"|\"number\"|\"boolean\")}, values: Row[]){\n      /* Manually overwrite all of the properties of the DataFrame */\n      this.columns = columns;\n      this.dtypes = dtypes;\n      this.values = values;\n      this.__headers = new Set(columns);\n    }\n\n    concat(other:DataFrame, columnSelection: (\"inner\" | \"outer\" | \"left\") = \"outer\"):DataFrame{\n      let other_cols = other.columns;\n\n      let columns:string[];\n      switch (columnSelection){\n        case \"inner\":\n          //List of columns is all shared columns;\n          columns = this.columns.filter(col => other.__headers.has(col));\n          break;\n        case \"outer\":\n          let a = this.columns;\n          let b = other.columns;\n\n          //List of columns is all from a, then all from b that aren't in a.\n          columns = a.concat(b.filter(col => !this.__headers.has(col)))\n          break;\n        case \"left\":\n          //List of columns is simply the columns in this df\n          columns = this.columns;\n          break;\n      }\n\n      // Helper to align rows to the unified column set\n      function alignRow(row: Row, columns: string[]): Row {\n        const aligned: Row = {};\n        for (const col of columns) {\n          aligned[col] = row[col] ?? null; // Fill missing with null\n        }\n        return aligned;\n      }\n      \n      const newData: Row[] = [\n        ...this.values.map(row => alignRow(row, columns)),\n        ...other.values.map(row => alignRow(row, columns)),\n      ];\n\n      // Convert back to array-of-arrays for constructor: [columns, ...rows]\n      const dataAsMatrix: (string | number | boolean | null)[][] = [\n        columns,\n        ...newData.map(row => columns.map(col => row[col])),\n      ];\n\n      return new DataFrame(dataAsMatrix);\n    }\n\n    add_column(columnName:string, values:(string|number|boolean)[]|(string|number|boolean)):DataFrame{\n      let new_df = this.copy();\n\n      let inp_values:(string|number|boolean)[];\n      if (Array.isArray(values)){\n        if (values.length != this.values.length) {\n          throw RangeError(`Length Mismatch:\\nSize of ${columnName} - ${values.length}\\nSize of df ${this.values.length}`);\n        }\n        inp_values = values;\n      }\n      else{\n        inp_values = Array(this.values.length).fill(values);\n      }\n\n      let old_size = new_df.__headers.size;\n      new_df.__headers.add(columnName)\n\n      if (new_df.__headers.size == old_size) {\n        throw RangeError(`Key \"${columnName}\" already in df`);\n      }\n      new_df.columns.push(columnName);\n      let dtype = detectColumn(inp_values as string[]);\n      new_df.dtypes[columnName] = dtype;\n\n      new_df.values.forEach((row, index) => {\n        row[columnName] = inp_values[index]\n      });\n\n      return new_df;\n    }\n\n    copy(): DataFrame {\n      // Use JSON to force a deep copy\n      return new DataFrame(JSON.parse(JSON.stringify(this.to_array())));\n    }\n    shape(): [number, number] {\n      return [this.values.length, this.columns.length]\n    }\n\n    get_column(key:string):(string|number|boolean)[]{\n      this.__check_membership(key);\n      return this.values.map(row => row[key]);\n    }\n\n    get_columns(...keys: string[]): DataFrame {\n      //Check that all keys are present in the df\n      keys.forEach(key => this.__check_membership(key));\n\n      let values = this.values.map(row => {\n        return keys.map(key => row[key]);\n      });\n\n      return new DataFrame([keys, ...values]);\n    }\n\n    drop(...columnsToDrop: string[]): DataFrame {\n      // Ensure all columns exist before proceeding\n      columnsToDrop.forEach(col => this.__check_membership(col));\n\n      // New columns excluding the dropped ones\n      const newColumns = this.columns.filter(col => !columnsToDrop.includes(col));\n\n      // New values excluding the dropped columns\n      const newValues = this.values.map(row => {\n        let newRow: Row = {};\n        newColumns.forEach(col => newRow[col] = row[col]); // Keep only selected columns\n        return newRow;\n      });\n\n      // Convert to DataFrame format\n      const resultData = [newColumns, ...newValues.map(row => newColumns.map(col => row[col]))];\n\n      return new DataFrame(resultData);\n    }\n\n    filter(key: string, predicate: (value: string | number | boolean) => boolean): DataFrame {\n      // Check if the key exists in the dataframe\n      this.__check_membership(key);\n\n      // Filter rows based on the predicate function\n      const filteredValues = this.values.filter(row => predicate(row[key]));\n\n      // Create a new DataFrame with only the filtered rows\n      return new DataFrame([this.columns, ...filteredValues.map(row => this.columns.map(col => row[col]))]);\n    }\n\n    // 1. Count non-null values per column\n    count(column: string): number {\n      this.__check_membership(column);\n\n      return this.values.filter(row => row[column] !== null && row[column] !== undefined && row[column] !== \"\").length;\n    }\n\n    // 2. Sum of numeric column values\n    sum(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.reduce((acc, val) => acc + val, 0);\n    }\n\n    // 3. Mean (Average) of a numeric column\n    mean(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.length > 0 ? this.sum(column) / values.length : NaN;\n    }\n\n    // Alias for mean\n    average(column: string): number {\n      return this.mean(column);\n    }\n\n    // 4. Minimum value in a numeric column\n    min(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.length > 0 ? Math.min(...values) : NaN;\n    }\n\n    // 5. Maximum value in a numeric column\n    max(column: string): number {\n      const values = this.__check_numeric(column);\n      return values.length > 0 ? Math.max(...values) : NaN;\n    }\n\n    // 6. Standard Deviation in a numeric columns\n    std_dev(column: string, bessel: boolean = true): number {\n      const values = this.__check_numeric(column);\n      const n = values.length;\n      if (n <= 1) return NaN;\n\n      const mean = values.reduce((acc, val) => acc + val, 0) / n;\n      const divisor = bessel ? n - 1 : n;\n\n      return Math.sqrt(\n        values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / divisor\n      );\n    }\n\n    //7. Quantiles\n    quantile(column: string, q: number): number {\n      this.__check_numeric(column); // Ensure the column is numeric\n      const values = this.__check_numeric(column).sort((a, b) => a - b); // Sort values\n      const pos = (values.length - 1) * q/100;\n      const base = Math.floor(pos);\n      const rest = pos - base;\n\n      if (values[base + 1] !== undefined) {\n        return values[base] + rest * (values[base + 1] - values[base]);\n      } else {\n        return values[base];\n      }\n    }\n\n    //8. Median\n    median(column:string): number{\n      return this.quantile(column, 50);\n    }\n\n    unique(column:string): (string|number|boolean)[]{\n      this.__check_membership(column);\n\n      return Array.from(new Set(this.values.map(row => row[column])));\n    }\n    getNumericColumns(): string[] {\n      return this.columns.filter(col => this.dtypes[col] === \"number\");\n    }\n\n    describe(): DataFrame {\n      const numericCols = this.getNumericColumns();\n\n      const stats = [\n        \"Count\",\n        \"Mean\",\n        \"Standard Deviation\",\n        \"Minimum\",\n        \"1st Quartile\",\n        \"Median\",\n        \"3rd Quartile\",\n        \"Maximum\"\n      ];\n\n      const summaryMap: { [col: string]: (string | number)[] } = {};\n\n      for (let col of numericCols) {\n        summaryMap[col] = [];\n\n        for (let stat of stats) {\n          switch (stat) {\n            case \"Count\":\n              summaryMap[col].push(this.count(col));\n              break;\n            case \"Mean\":\n              summaryMap[col].push(this.mean(col));\n              break;\n            case \"Standard Deviation\":\n              summaryMap[col].push(this.std_dev(col));\n              break;\n            case \"Minimum\":\n              summaryMap[col].push(this.min(col));\n              break;\n            case \"1st Quartile\":\n              summaryMap[col].push(this.quantile(col, 25));\n              break;\n            case \"Median\":\n              summaryMap[col].push(this.median(col));\n              break;\n            case \"3rd Quartile\":\n              summaryMap[col].push(this.quantile(col, 75));\n              break;\n            case \"Maximum\":\n              summaryMap[col].push(this.max(col));\n              break;\n          }\n        }\n      }\n\n      const summaryRows: (string | number)[][] = [];\n\n      for (let col of numericCols) {\n        summaryRows.push([col, ...summaryMap[col]]);\n      }\n\n      return new DataFrame([\n        [\"Column\", ...stats],\n        ...summaryRows\n      ]);\n    }\n\n    groupBy(\n      group_keys: string[] | string,\n      valueCols: string[] | \"all\",\n      aggFuncs: (\"sum\" | \"mean\" | \"count\" | \"min\" | \"max\" | \"std_dev\")[] | (\"sum\" | \"mean\" | \"count\" | \"min\" | \"max\" | \"std_dev\")\n    ): DataFrame {\n      let keys: string[];\n      if (typeof (group_keys) == \"string\") {\n        keys = [group_keys]\n      }\n      else {\n        keys = group_keys;\n      }\n\n      keys.forEach(key => this.__check_membership(key));\n      keys.forEach(key => column_violates_separator(key));\n\n      let valueColumns: string[];\n      if (typeof (valueCols) == \"string\") {\n        valueColumns = this.getNumericColumns();\n        // Filter out any columns that are in the keys list\n        valueColumns = valueColumns.filter(col => !keys.includes(col));\n      }\n      else {\n        valueColumns = valueCols;\n      }\n\n      valueColumns.forEach(col => this.__check_membership(col));\n\n      // If only one aggFunc is provided, apply it to all valueColumns\n      if (typeof (aggFuncs) == \"string\") {\n        aggFuncs = new Array(valueColumns.length).fill(aggFuncs);\n      }\n      else if (aggFuncs.length === 1) {\n        aggFuncs = new Array(valueColumns.length).fill(aggFuncs[0]);\n      }\n\n\n      if (aggFuncs.length !== valueColumns.length) {\n        throw new Error(\n          `Number of value columns (${valueColumns.length}) must match number of aggFuncs (${aggFuncs.length}), or only one aggFunc should be provided.`\n        );\n      }\n\n      const grouped: { [groupKey: string]: Row[] } = {};\n\n      for (let row of this.values) {\n        const groupKey = keys.map(k => row[k]).join(SEPARATOR);\n        if (!grouped[groupKey]) {\n          grouped[groupKey] = [];\n        }\n        grouped[groupKey].push(row);\n      }\n\n      const aggregatedRows: (string | number | boolean)[][] = [];\n      const resultHeaders: string[] = [...keys];\n\n      // Build output headers\n      valueColumns.forEach((col, idx) => {\n        resultHeaders.push(`${col}_${aggFuncs[idx]}`);\n      });\n\n      for (let groupKey in grouped) {\n        const rows = grouped[groupKey];\n        const groupDF = new DataFrame([\n          this.columns,\n          ...rows.map(r => this.columns.map(col => r[col])),\n        ]);\n\n        const keyParts = groupKey.split(SEPARATOR);\n        const aggregatedRow: (string | number | boolean)[] = [...keyParts];\n\n        valueColumns.forEach((col, idx) => {\n          const func = aggFuncs[idx];\n          let value: number;\n\n          switch (func) {\n            case \"sum\":\n              value = groupDF.sum(col);\n              break;\n            case \"mean\":\n              value = groupDF.mean(col);\n              break;\n            case \"count\":\n              value = groupDF.count(col);\n              break;\n            case \"min\":\n              value = groupDF.min(col);\n              break;\n            case \"max\":\n              value = groupDF.max(col);\n              break;\n            case \"std_dev\":\n              value = groupDF.std_dev(col);\n              break;\n          }\n\n          aggregatedRow.push(value);\n        });\n\n        aggregatedRows.push(aggregatedRow);\n      }\n\n      return new DataFrame([resultHeaders, ...aggregatedRows]);\n    }\n\n    operateColumns(operator:(\"*\" | \"+\" | \"-\" | \"/\"), col1: string, col2: string):number[]{\n      // Check if both columns exist\n      this.__check_membership(col1);\n      this.__check_membership(col2);\n\n      // Ensure the columns are numeric\n      let nums1 = this.__check_numeric(col1);\n      let nums2 = this.__check_numeric(col2);\n\n      // Create the new values array by dividing values of col1 and col2\n      const transformedValues = nums1.map((n1, i) => {\n        let n2 = nums2[i];\n        switch (operator){\n          case \"+\": return n1 + n2\n          case \"-\": return n1 - n2\n          case \"*\": return n1 * n2\n          case \"/\": return n1 / n2\n        }\n      })\n      return transformedValues\n    }\n\n\n    query(condition: (row: Row) => boolean): DataFrame {\n      // Filter rows based on the provided condition function\n      const filteredValues = this.values.filter(row => condition(row));\n\n      // Convert filtered values into the DataFrame format\n      const resultData = [this.columns, ...filteredValues.map(row =>\n        this.columns.map(col => row[col])\n      )];\n\n      return new DataFrame(resultData);\n    }\n\n    isin(column: string, values: Set<string | number | boolean>): DataFrame {\n      this.__check_membership(column); // make sure column exists\n\n      // Filter rows where the column's value is in the Set\n      const filteredRows = this.values.filter(row => values.has(row[column]));\n\n      // Rebuild data array for new DataFrame\n      const dataArray = [\n        this.columns,\n        ...filteredRows.map(row => this.columns.map(col => row[col]))\n      ];\n\n      return new DataFrame(dataArray);\n    }\n\n    sortBy(columns: string[], ascending: boolean[] = []): DataFrame {\n      // Ensure all columns exist in the DataFrame\n      columns.forEach(col => this.__check_membership(col));\n\n      // If only one sorting direction is provided, apply it to all columns\n      if (ascending.length === 1) {\n        ascending = Array(columns.length).fill(ascending[0]);\n      }\n\n      // Sort rows based on columns and their corresponding sort order (ascending or descending)\n      const sortedRows = [...this.values].sort((rowA, rowB) => {\n        for (let i = 0; i < columns.length; i++) {\n          const col = columns[i];\n          const direction = ascending[i] ? 1 : -1;\n          if (rowA[col] < rowB[col]) return -direction;\n          if (rowA[col] > rowB[col]) return direction;\n        }\n        return 0;\n      });\n\n      // Rebuild the data array for the new sorted DataFrame\n      const dataArray = [\n        this.columns,\n        ...sortedRows.map(row => this.columns.map(col => row[col]))\n      ];\n\n      return new DataFrame(dataArray);\n    }\n\n    merge(other: DataFrame, on: string[], how: \"inner\" | \"left\" | \"outer\" = \"inner\"): DataFrame {\n      // Ensure columns to join on exist in both DataFrames\n      on.forEach(col => {\n        this.__check_membership(col);\n        other.__check_membership(col);\n      });\n\n      // Join rows based on the selected `how` type\n      let mergedRows: Row[] = [];\n\n      switch (how) {\n        case \"inner\":\n          // Perform an inner join (only matching rows)\n          mergedRows = this.values.filter(row =>\n            other.values.some(oRow => on.every(col => row[col] === oRow[col]))\n          ).map(row => {\n            const matchedRows = other.values.filter(oRow =>\n              on.every(col => row[col] === oRow[col])\n            );\n            return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n          });\n          break;\n\n        case \"left\":\n          // Perform a left join (all rows from the left DataFrame and matching rows from the right)\n          mergedRows = this.values.map(row => {\n            const matchedRows = other.values.filter(oRow =>\n              on.every(col => row[col] === oRow[col])\n            );\n            return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n          });\n          break;\n\n        case \"outer\":\n          // Perform an outer join (all rows from both DataFrames, matching where possible)\n          mergedRows = [\n            ...this.values.map(row => {\n              const matchedRows = other.values.filter(oRow =>\n                on.every(col => row[col] === oRow[col])\n              );\n              return matchedRows.length > 0 ? { ...row, ...matchedRows[0] } : row;\n            }),\n            ...other.values.filter(oRow =>\n              !this.values.some(row =>\n                on.every(col => row[col] === oRow[col])\n              )\n            )\n          ];\n          break;\n\n        default:\n          throw new Error(\"Invalid join type. Use 'inner', 'left', or 'outer'.\");\n      }\n\n      // Combine the columns of both DataFrames, keeping the 'on' columns intact\n      const mergedColumns = [\n        ...this.columns, // Keep the columns from the left DataFrame\n        ...other.columns.filter(col => !on.includes(col)) // Exclude duplicate 'on' columns from the right DataFrame\n      ];\n\n      // Rebuild the data array for the new merged DataFrame\n      const dataArray = [\n        mergedColumns,\n        ...mergedRows.map(row => mergedColumns.map(col => row[col] || null)) // Handle any missing values\n      ];\n\n      return new DataFrame(dataArray);\n    }\n\n    iterrows(): [Row, number][]{\n      return this.values.map((row, idx) => [row, idx]);\n    }\n\n    to_json(headers:boolean = true):string{\n      return JSON.stringify(this.to_array(headers));\n    }\n\n    rename(columnsMap: { [oldName: string]: string }): DataFrame {\n      // Make sure all keys in columnsMap exist in the DataFrame\n      for (let oldCol in columnsMap) {\n        this.__check_membership(oldCol);\n      }\n\n      // Create new columns array by replacing old column names with new ones\n      const newColumns = this.columns.map(col => columnsMap[col] || col);\n      \n      // Rebuild the data array with updated headers\n\n      return new DataFrame([newColumns, ...this.to_array(false)]);\n    }\n\n    add_formula_column(columnName:string, formula:string):DataFrame{\n      /* Append a table-style formula column\n      Example: [@Col1] + [@Col2]\n      */\n      let formula_col:string[] = Array(this.shape()[0]).fill(formula);\n      return this.add_column(columnName, formula_col);\n    }\n\n    fill_na(columnName:(string|string[]|\"ALL\"), method: (\"prev\"|\"next\"|\"value\"), value?: string|number|boolean):DataFrame{\n      if (typeof columnName != \"string\" || columnName == \"ALL\"){\n        let columns:string[];\n        if (columnName == \"ALL\"){\n          columns = this.columns;\n        }\n        else{\n          columns = columnName;\n        }\n\n        let df = this.copy()\n        columns.forEach(c => df = df.fill_na(c,method,value));\n        return df;\n      }\n      else{\n        this.__check_membership(columnName);\n\n        //Deep copy before\n        let df = this.copy();\n\n        let replace_value: string | number | boolean;\n        switch (method) {\n          case \"prev\":\n            let warnings: number[] = [];\n            for (let [row, index] of df.iterrows()) {\n              if (row[columnName] != \"\") {\n                replace_value = row[columnName];\n              }\n              else {\n                if (replace_value == null) {\n                  warnings.push(index);\n                }\n                row[columnName] = replace_value;\n              }\n            }\n\n            if (warnings.length > 0) {\n              console.log(`WARNING: not all values were replaced (no header value to assign)\\nMissed values in rows: ${warnings}`);\n            }\n            break;\n          case \"next\":\n            let to_replace: number[] = [];\n            for (let [row, index] of df.iterrows()) {\n              if (row[columnName] == \"\") {\n                to_replace.push(index);\n              }\n              else {\n                replace_value = row[columnName];\n                while (to_replace.length > 0) {\n                  df.values[to_replace.pop()][columnName] = replace_value;\n                }\n              }\n            }\n\n            //If there are non-replaced values at the end of iteration log a warning\n            if (to_replace.length > 0) {\n              console.log(`WARNING: not all values were replaced (no bottom value to assign)\\nMissed values in rows: ${to_replace}`);\n            }\n            break;\n          case \"value\":\n            if (value == null) {\n              throw new SyntaxError('If fillNa() method is \"value\" a value argument must be provided');\n            }\n            df.values.filter(row => row[columnName] == null).forEach(row => row[columnName] = value);\n            break;\n          default: throw new SyntaxError('fillNa() method must be \"prev\", \"next\", or \"value\"')\n        }\n        return df;\n      }\n    }\n\n    to_worksheet(worksheet:ExcelScript.Worksheet, method: (\"o\"|\"a\") = \"o\"){\n      //Include headers only when overwriting\n      let export_array:(string|number|boolean)[][] = this.to_array(method == \"o\");\n      let export_range:ExcelScript.Range;\n      let [n_rows, n_cols] = this.shape();\n\n      //Overwrite logic\n      if (method == \"o\"){\n        //Overwrite the sheet\n        worksheet.getUsedRange()?.setValue(\"\");\n        //Get entire export range\n        export_range = worksheet.getRange(\"A1\").getResizedRange(n_rows, n_cols - 1)\n        //Import Just Headers for Property Table Initializations (with names)\n        let header_range = worksheet.getRange(\"A1\").getResizedRange(0,n_cols - 1);\n        header_range.setValues([this.columns]);\n        //Then try to set a table to the export range\n        try {\n          worksheet.addTable(export_range, true);\n        }\n        catch {\n          console.log(`A table already exists at ${export_range.getAddressLocal()}, proceeding anyways.`);\n        }\n      }\n      //Append logic\n      else if (method == \"a\"){\n        let used_rng = worksheet.getUsedRange();\n        if (used_rng == null){\n          //Recursively use overwrite logic if the appending sheet is empty\n          return this.to_worksheet(worksheet,\"o\");\n        }\n        //Last row of the existing worksheet\n        let end_row = worksheet.getUsedRange().getLastRow()\n        //First cell of the import area\n        let start_rng = end_row.getOffsetRange(1,0).getColumn(0);\n        export_range = start_rng.getResizedRange(n_rows - 1, n_cols - 1); \n      }\n      else{\n        throw new SyntaxError(\"Sheet export method must either be 'o' to overwrite or 'a' to append\")\n      }\n\n      \n      //Import all values (including the headers again);\n      export_range.setValues(export_array);\n\n      //Print a helpful message if this export wasn't done as a helper method\n      if (worksheet.getName() != DEV_SHEET_NAME) {\n        console.log(`Dataframe Written to ${export_range.getAddressLocal()}`);\n      }\n      //*/\n    }\n\n    hardcode_formulas(workbook: ExcelScript.Workbook): DataFrame {\n    /*\n      Calculate and Hardcode all formula results in the input df. \n      Used to aggregate formula based calculations\n    */\n      let ExportSheet = workbook.addWorksheet(DEV_SHEET_NAME);\n      this.to_worksheet(ExportSheet, 'o');\n      let calculated_df = new DataFrame(ExportSheet.getUsedRange().getValues());\n      ExportSheet.delete();\n      return calculated_df\n    }\n\n    to_csv(headers:boolean = true, separator:string = \",\"):string{\n      return this.to_array(headers).map(row => row.join(separator)).join(\"\\n\");\n    }\n\n    melt(newColumnName: string, newValueName:string, ...columns:string[]): DataFrame{\n      columns.forEach(col => this.__check_membership(col));\n\n      let cols_set = new Set(columns);\n      let other_cols = Array.from(this.__headers).filter(col => !cols_set.has(col));\n      let output_values:(string|number|boolean)[][] = [[...other_cols,newColumnName,newValueName]];\n\n      for (let row of this.values){\n        let other_vals = other_cols.map(col => row[col]);\n        columns.forEach(col => {\n          let val = row[col]\n          output_values.push([...other_vals,col,val]);\n        });\n      }\n      //console.log(output_values);\n      return new DataFrame(output_values);\n    }\n\n    melt_except(newColumnName: string, newValueName:string, ...exceptColumns:string[]):DataFrame{\n      exceptColumns.forEach(col => this.__check_membership(col));\n\n      let cols_set = new Set(exceptColumns);\n      let melt_cols = Array.from(this.__headers).filter(col => !cols_set.has(col));\n      return this.melt(newColumnName,newValueName,...melt_cols);\n    }\n\n    apply<T>(fn: (row: Row) => T):T[]{\n      return this.values.map(row => fn(row));\n    }   \n\n    drop_rows(...rows:number[]):DataFrame{\n      let df = this.copy();\n\n      let to_avoid = new Set(rows.map(row => {\n        if (row >= 0){return row}\n        else{\n          let adjusted = this.values.length + row;\n          if (adjusted < 0){\n            throw new RangeError(`Not enough rows in DataFrame\\nInput ${row}, while df has ${this.values.length} rows`);\n          }\n          return adjusted;\n        }\n      }));\n\n      df.values = df.values.filter((_, index) => !to_avoid.has(index));\n      return df;\n    }\n\n    head(n_rows:number = 10):DataFrame{\n      if (this.values.length <= n_rows){return this}\n      let df = this.copy();\n      df.values = this.values.slice(0,n_rows);\n      return df;\n    }\n\n    tail(n_rows:number = 10):DataFrame{\n      if (this.values.length <= n_rows) { return this }\n      let df = this.copy();\n      df.values = this.values.slice(this.values.length - n_rows);\n      return df;\n    }\n\n    print(n_rows: number = 5) {\n      const totalRows = this.values.length;\n      const headers = this.columns;\n\n      const headRows = this.head(n_rows).values;\n      const tailRows = this.tail(n_rows).values;\n\n      const rowsToPrint = totalRows <= n_rows * 2 ? this.values : [...headRows, \"...\", ...tailRows];\n\n      // Convert values to array of arrays for consistent handling\n      const dataArray = rowsToPrint.map(row => {\n        if (row === \"...\") return \"...\";\n        return headers.map(col => row[col] !== undefined ? String(row[col]) : \"\");\n      });\n\n      // Calculate column widths based on max length\n      const colWidths = headers.map((header, i) => {\n        const maxDataWidth = dataArray.reduce((max, row) => {\n          if (row === \"...\") return max;\n          return Math.max(max, row[i]?.length || 0);\n        }, header.length);\n        return maxDataWidth;\n      });\n\n      // Format header and divider\n      const pad = (text: string, width: number) => text.padEnd(width, \" \");\n      const headerRow = \"| \" + headers.map((h, i) => pad(h, colWidths[i])).join(\" | \") + \" |\";\n      const divider = \"| \" + colWidths.map(w => \"-\".repeat(w)).join(\" | \") + \" |\";\n\n      // Format data rows\n      const dataRows = dataArray.map(row => {\n        if (row === \"...\") {\n          return \"| \" + colWidths.map(w => pad(\"...\", w)).join(\" | \") + \" |\";\n        } else {\n          return \"| \" + row.map((val, i) => pad(val, colWidths[i])).join(\" | \") + \" |\";\n        }\n      });\n\n      let [number_of_df_rows, n_cols] = this.shape();\n      let size_statement = `(${number_of_df_rows} rows x ${n_cols} columns)`\n      console.log([headerRow, divider, ...dataRows,\"\",size_statement].join(\"\\n\"));\n    }\n\n    validate_key(key:DataFrame, on: [string,string]|string, errors: (\"raise\" | \"return\") = \"raise\"):(string|number|boolean)[]|void{\n      let left_on:string;\n      let right_on:string;\n\n      if (typeof(on) == 'string'){\n        [left_on, right_on] = [on, on];\n      }\n      else{\n        [left_on, right_on] = on;\n      }\n\n      this.__check_membership(left_on);\n      key.__check_membership(right_on);\n\n      let left_values = this.get_column(left_on);\n      let right_values = new Set(key.get_column(right_on));\n\n      let not_in_key = left_values.filter(v => !right_values.has(v));\n\n      if (not_in_key.length != 0){\n        if (errors == \"raise\"){\n          throw new Error(`KeyIncompleteError: The following values were not found in the selected key\\n[${not_in_key.join(',')}]`)\n        }\n        else{\n          return not_in_key;\n        }\n      }\n    }\n  }\n}\nconst fr = frosts;\n\nfunction main(workbook: ExcelScript.Workbook) {\n  //YOUR CODE GOES HERE\n  // See full documentation and usage instructions here: https://joeyrussoniello.github.io/frosts/\n\n  \n}","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}